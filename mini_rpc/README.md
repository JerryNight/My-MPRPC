## 核心阶段与学习路径
### 1.链路层 (Link Layer)：整个系统的基石。
目标: 实现一个基于 epoll 的高性能 TCP 服务，能够高效地接收和发送二进制数据。
学习重点: 序列化与反序列化 (Protobuf)，TcpServer 类设计与实现。socket 编程、非阻塞 I/O、epoll 原理与实践。

### 2.协议层 (Protocol Layer)：我们的 RPC 系统需要一个自定义的协议来规范数据格式。
目标: 定义一个 RPC 协议头，包含请求的类型、方法名、参数长度等元信息。
学习重点: 网络协议设计、报文分包与组包。

### 3.序列化层 (Serialization Layer)：将对象转换为二进制数据。
目标: 封装 Protobuf，使其能更方便地与协议层对接。

### 4.代理层 (Proxy Layer)：这是 RPC 系统的“门面”，客户端通过代理层像调用本地函数一样调用远程函数。
目标: 使用 C++ 模板和宏来生成代理类，实现对远程调用的封装。
学习重点: C++ 模板元编程、宏的高级用法。

### 5.路由层 (Routing Layer)：客户端如何知道去哪台服务器发起调用？
目标: 实现一个客户端路由策略，比如简单的负载均衡。
学习重点: 负载均衡算法（如轮询、随机）。

### 6.注册中心层 (Registry Center Layer)：服务端如何被发现？
目标: 实现一个简单的服务注册与发现机制，让服务提供者能注册自己，服务消费者能找到它们。
学习重点: 分布式系统原理、服务注册与发现模型。

### 7.容错层 (Fault Tolerance Layer)：当服务出现故障时，系统如何应对？
目标: 实现超时、重试等容错机制，提高系统的健壮性。
学习重点: 分布式系统中的容错设计。

#### 协议层：
一个完整的RPC协议，应包含：
1. 协议头：简单的协议头设计，可以是一个魔数+一个数据长度（`magic`+`length`）
2. 服务名长度：一个4字节整数，表示服务名的长度
3. 服务名：一个字符串
4. 方法名长度：一个4字节整数，表示方法名的长度
5. 方法名：一个字符串
6. Protobuf 消息体：序列化后的数据

#### 使用Protoc生成RPC代码
由于protobuf版本较低，需要手动实现服务类：服务基类 + 服务实现类
重写 `CallMethod` 方法：
> `CallMethod`封装了服务函数的具体实现，是底层网络和上层业务逻辑的唯一入口，由上层的`TcpServer`调用
> `CallMethod`接收泛型`Message`指针，要进行类型转换

#### 代码生成器：解析 proto 文件，自动生成 c++ 文件
一个通用的RPC框架，需要一个够能-自动生成服务实现者代码-的工具。
代码生成器的工作流程：
1. 读取 `Proto` 文件
2. 解析文件，解析出服务名、方法名、请求类型、响应类型
3. 生成 c++ 代码文件，包含处理网络通信的通用逻辑。