### 核心组件

```
LoadBalancer (抽象基类)
├── RoundRobinLoadBalancer          (轮询)
├── WeightedRoundRobinLoadBalancer  (加权轮询)
├── LeastConnectionLoadBalancer     (最少连接)
├── ConsistentHashLoadBalancer      (一致性哈希)
└── LoadBalancerFactory              - 使用工厂模式创建各种负载均衡器实例
```

## 负载均衡策略

### 1. 轮询 (Round Robin)

**特点：**
- 按顺序依次选择服务实例
- 简单高效，适合服务实例性能相近的场景
- 线程安全，使用原子操作

**使用场景：**
- 后端服务性能相同
- 请求处理时间相近
- 无状态服务

### 2. 加权轮询 (Weighted Round Robin)

**特点：**
- 根据服务实例权重进行分配
- 权重越高，获得的请求越多
- 平滑加权算法，避免流量突增

**使用场景：**
- 服务实例性能差异较大
- 需要精确控制流量分配
- 机器配置不同

### 3. 最少连接 (Least Connection)

**特点：**
- 选择当前连接数最少的实例
- 动态适应服务实例负载
- 需要维护连接状态

**使用场景：**
- 请求处理时间差异大
- 长连接服务
- 需要考虑实际负载的场景

### 4. 一致性哈希 (Consistent Hash)

**特点：**
- 相同的key总是路由到同一个实例
- 节点增减时影响最小
- 使用虚拟节点提高均匀性

**使用场景：**
- 需要会话保持
- 缓存服务（避免缓存失效）
- 有状态服务

### 有状态服务

服务端需要保存用户的上下文信息（比如登录状态、购物车、连接状态等），客户端的多次请求之间是有关联的，必须由同一个服务节点处理，或者服务端需要共享状态信息。

**特点：**
- 需要保存用户会话或状态；
- 扩展和迁移较困难；
- 需要额外机制（如会话同步、分布式缓存）才能实现高可用。
- 场景：登录认证系统（使用Session）、聊天服务器、游戏服务器、缓存系统、购物车服务等

### 无状态服务

服务端不保存客户端的上下文信息（Session、登录状态、历史请求等），每一次请求都是独立的、完整的。

**特点：**

- 不依赖用户的历史状态；
- 每个请求都能被任意一台服务器处理；
- 扩展性极好（非常适合负载均衡、容器部署）。
- 场景：Web 静态资源服务、RESTful API 接口、文件上传服务、计算任务服务等

## 为什么一致性哈希算法可以解决有状态服务？

一致性哈希将哈希空间想象成一个**环状**的结构，称之为**哈希环**。
使用哈希算法将服务器地址映射到哈希环上，当用户请求到来时，将用户请求进行同样的哈希运算，也映射到哈希环上，然后按照顺时针方向寻找，第一个找到的服务器地址，就是用来提供服务的服务器地址。
可以把一致性哈希想象成一个环形的图书馆书架。
- 哈希环就是这个环形书架，上面有从 0 到 360 度的刻度。
- 服务器就像是几个图书管理员，他们各自站在书架上的特定位置。
- 请求就像一本本书，每本书都有一个唯一的编号。
当你需要找一本书时，你会先找到这本书的编号，然后沿着书架顺时针走，遇到的第一个图书管理员，就是负责这本书的人。
当图书馆新增一个管理员或者某个管理员请假时(服务器宕机或扩展新服务器时)，
- 新来的管理员只会从他顺时针方向的管理员那里接管一部分书籍，对其他管理员没有影响。
- 生病的管理员负责的书籍，会全部转移给他顺时针方向的下一个管理员，对其他管理员也没有影响。
这保证了不管服务器怎么变动，只有极少部分的请求会重新被分配，大部分请求仍然会找到原来的服务器。